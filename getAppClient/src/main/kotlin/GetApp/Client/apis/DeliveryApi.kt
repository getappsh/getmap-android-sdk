/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package GetApp.Client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import GetApp.Client.models.DeliveryStatusDto
import GetApp.Client.models.PrepareDeliveryReqDto
import GetApp.Client.models.PrepareDeliveryResDto

import GetApp.Client.infrastructure.ApiClient
import GetApp.Client.infrastructure.ApiResponse
import GetApp.Client.infrastructure.ClientException
import GetApp.Client.infrastructure.ClientError
import GetApp.Client.infrastructure.ServerException
import GetApp.Client.infrastructure.ServerError
import GetApp.Client.infrastructure.MultiValueMap
import GetApp.Client.infrastructure.RequestConfig
import GetApp.Client.infrastructure.RequestMethod
import GetApp.Client.infrastructure.ResponseType
import GetApp.Client.infrastructure.Success

class DeliveryApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * 
     * Get status of prepared delivery
     * @param catalogId 
     * @return PrepareDeliveryResDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deliveryControllerGetPreparedDeliveryStatus(catalogId: kotlin.String) : PrepareDeliveryResDto {
        val localVarResponse = deliveryControllerGetPreparedDeliveryStatusWithHttpInfo(catalogId = catalogId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PrepareDeliveryResDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get status of prepared delivery
     * @param catalogId 
     * @return ApiResponse<PrepareDeliveryResDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deliveryControllerGetPreparedDeliveryStatusWithHttpInfo(catalogId: kotlin.String) : ApiResponse<PrepareDeliveryResDto?> {
        val localVariableConfig = deliveryControllerGetPreparedDeliveryStatusRequestConfig(catalogId = catalogId)

        return request<Unit, PrepareDeliveryResDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deliveryControllerGetPreparedDeliveryStatus
     *
     * @param catalogId 
     * @return RequestConfig
     */
    fun deliveryControllerGetPreparedDeliveryStatusRequestConfig(catalogId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/delivery/preparedDelivery/{catalogId}".replace("{"+"catalogId"+"}", encodeURIComponent(catalogId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Prepare delivery
     * @param prepareDeliveryReqDto 
     * @return PrepareDeliveryResDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deliveryControllerPrepareDelivery(prepareDeliveryReqDto: PrepareDeliveryReqDto) : PrepareDeliveryResDto {
        val localVarResponse = deliveryControllerPrepareDeliveryWithHttpInfo(prepareDeliveryReqDto = prepareDeliveryReqDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PrepareDeliveryResDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Prepare delivery
     * @param prepareDeliveryReqDto 
     * @return ApiResponse<PrepareDeliveryResDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deliveryControllerPrepareDeliveryWithHttpInfo(prepareDeliveryReqDto: PrepareDeliveryReqDto) : ApiResponse<PrepareDeliveryResDto?> {
        val localVariableConfig = deliveryControllerPrepareDeliveryRequestConfig(prepareDeliveryReqDto = prepareDeliveryReqDto)

        return request<PrepareDeliveryReqDto, PrepareDeliveryResDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deliveryControllerPrepareDelivery
     *
     * @param prepareDeliveryReqDto 
     * @return RequestConfig
     */
    fun deliveryControllerPrepareDeliveryRequestConfig(prepareDeliveryReqDto: PrepareDeliveryReqDto) : RequestConfig<PrepareDeliveryReqDto> {
        val localVariableBody = prepareDeliveryReqDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/delivery/prepareDelivery",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This service message allows the consumer to report of the delivery status
     * @param deliveryStatusDto 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deliveryControllerUpdateDownloadStatus(deliveryStatusDto: DeliveryStatusDto) : Unit {
        val localVarResponse = deliveryControllerUpdateDownloadStatusWithHttpInfo(deliveryStatusDto = deliveryStatusDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This service message allows the consumer to report of the delivery status
     * @param deliveryStatusDto 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deliveryControllerUpdateDownloadStatusWithHttpInfo(deliveryStatusDto: DeliveryStatusDto) : ApiResponse<Unit?> {
        val localVariableConfig = deliveryControllerUpdateDownloadStatusRequestConfig(deliveryStatusDto = deliveryStatusDto)

        return request<DeliveryStatusDto, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deliveryControllerUpdateDownloadStatus
     *
     * @param deliveryStatusDto 
     * @return RequestConfig
     */
    fun deliveryControllerUpdateDownloadStatusRequestConfig(deliveryStatusDto: DeliveryStatusDto) : RequestConfig<DeliveryStatusDto> {
        val localVariableBody = deliveryStatusDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/delivery/updateDownloadStatus",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
